# Quickstart

In this section, we will show you how to create a simple Fibonacci program using the SP1 zkVM.

## Create Project

The first step is to create a new project using the `cargo prove new <name>` command. This command will create a new folder in your current directory.

<!-- TODO: At the beginning of this command, it should say "Creating a new SP1 project in the {} folder..." -->

```bash
cargo prove new fibonacci
cd fibonacci
```

<!-- Why do we have 2 Rust-toolchain files in the Fibonacci quickstart? One in script and one in program? -->

This will create a new project with the following structure:

```
.
├── program
│   ├── Cargo.lock
│   ├── Cargo.toml
│   ├── elf
│   │   └── riscv32im-succinct-zkvm-elf
│   └── src
│       └── main.rs
├── rust-toolchain
└── script
    ├── Cargo.lock
    ├── Cargo.toml
    ├── build.rs
    └── src
        └── bin
            ├── prove.rs
            └── vkey.rs

6 directories, 4 files
```

<!-- Just run "tree" to get this output -->

There are 2 directories (each a crate) in the project: 
- `program`: the source code that will be proven inside the zkVM.
- `script`: code that contains proof generation and verification code.

We recommend you install the [rust-analyzer](https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer) extension.
Note that if you use `cargo prove new` inside a monorepo, you will need to add the manifest file to `rust-analyzer.linkedProjects` to get full IDE support.

## Generate Proof

<!-- TODO: we should insert the program here -->
<!-- TODO: notice that the artifacts are not using the latest version of SP1, we should check that in CI if possible. -->

The program simply computes the `n`-th Fibonacci number.

Before we can run the program inside the zkVM, it must be compiled to a RISC-V executable using the `succinct` Rust toolchain. This is called an [ELF (Executable and Linkable Format)](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format). To compile the program, you can run `cd program && cargo prove build`, which will output the compiled ELF to the file `program/elf/riscv32im-succinct-zkvm-elf`. 

In our case, the `build.rs` file in the `script` directory will use run the above command automatically to build the ELF, meaning you don't have to manually run `cargo prove build` every time you make a change to the program.

To generate a proof, we take the ELF file generated by the `build.rs` file and execute it within the SP1 zkVM. The code in the `script` directory is already scaffolded with a script that has logic to generate a proof, save the proof to disk, and verify it.

```bash
cd script
RUST_LOG=info cargo run --release
```

<!-- Noticed that Fibonacci quickstart takes 20 seconds to run which is bad IMO, any way to fix? -->
<!-- 
Why is "collect_checkpoints" run twice? Imo looks bad in output.
2024-07-23T17:07:07.874856Z  INFO prove_core:collect_checkpoints: clk = 0 pc = 0x2017e8
2024-07-23T17:07:07.876264Z  INFO prove_core:collect_checkpoints: close time.busy=2.00ms time.idle=1.50µs
2024-07-23T17:07:07.877349Z  INFO prove_core:commit_checkpoint: clk = 0 pc = 0x2017e8     num=0
2024-07-23T17:07:07.881096Z  INFO prove_core:commit_checkpoint: close time.busy=4.52ms time.idle=708ns num=0 -->

The output should show
```
n: 20
2024-07-23T17:07:07.874856Z  INFO prove_core:collect_checkpoints: clk = 0 pc = 0x2017e8
2024-07-23T17:07:07.876264Z  INFO prove_core:collect_checkpoints: close time.busy=2.00ms time.idle=1.50µs
2024-07-23T17:07:07.913304Z  INFO prove_core:shard: close time.busy=32.2ms time.idle=791ns
2024-07-23T17:07:10.724280Z  INFO prove_core:commit: close time.busy=2.81s time.idle=1.25µs
2024-07-23T17:07:10.725923Z  INFO prove_core:prove_checkpoint: clk = 0 pc = 0x2017e8     num=0
2024-07-23T17:07:10.729130Z  INFO prove_core:prove_checkpoint: close time.busy=3.68ms time.idle=1.17µs num=0
2024-07-23T17:07:14.648146Z  INFO prove_core: execution report (totals): total_cycles=9329, total_syscall_cycles=20
2024-07-23T17:07:14.648180Z  INFO prove_core: execution report (opcode counts):
2024-07-23T17:07:14.648197Z  INFO prove_core:   1948 add
...
2024-07-23T17:07:14.648277Z  INFO prove_core: execution report (syscall counts):
2024-07-23T17:07:14.648408Z  INFO prove_core:   8 commit
...
2024-07-23T17:07:14.648858Z  INFO prove_core: summary: cycles=9329, e2e=9.193968459, khz=1014.69, proofSize=1419780
2024-07-23T17:07:14.653193Z  INFO prove_core: close time.busy=9.20s time.idle=12.2µs
Successfully generated proof!
fib(n): 10946
```

The program by default is quite small, so proof generation will only take a few seconds locally. After it generates, the proof will be verified for correctness.

<!-- TODO: should we add back serde/deserde of the proof? -->

## Generating Proofs on the Prover Network

<!-- TODO: link to prover network section -->
We *strongly recommend* that developers who want to use SP1 for non-trivial programs generate proofs on our [Prover Network's](...) private beta. The prover network generates SP1 proofs across multiple machines, reducing latency and also runs SP1 on optimized hardware instances that result in faster + cheaper proof generation times.

We recommend that for any production benchmarking, you use the prover network to estimate latency and costs of proof generation.

## Modifying the Program

You can play around with how many rounds of Fibonacci are executed by playing around with `n` (by default set to `20`) in the file `script/src/main.rs`. Note that the program panics if `n` is too large (`n > 186` to prevent integer overflow).

The ELF will be automatically rebuilt every time you modify the program. You can verify that the ELF was re-generated by looking in the `elf` directory and for a file called `riscv32im-succinct-zkvm-elf`:
```bash
ls elf # should show riscv32im-succinct-zkvm-elf
```